---
layout: post
title: MalwareTech Ransomware Writeup
---
## MalwareTech Ransomware1 Reversing challenge:

I was looking into the RE challenges posted by MalwareTech on his website found [here](https://www.malwaretech.com/beginner-malware-reversing-challenges). They deal with finding a flag in the Binaries in the form of **FLAG{}**. I solved all of them but the last [one](https://www.malwaretech.com/ransomware1), it dealt with a simple Ransomware sample that Encrypts some files with it's custom algorithm. With the zip file came a __flag.txt_encrypted__, and a **Sample Picture** folder with encrypted pictures by the same ransomware :

![alt text]({{ site.baseurl }}/images/flag_encrypted.png "{{ site.baseurl }}/images/flag_encrypted.png")

![alt text]({{ site.baseurl }}/images/pictures_encrypted.png "{{ site.baseurl }}/images/pictures_encrypted.png")

![alt text]({{ site.baseurl }}/images/ransomware.png "{{ site.baseurl }}/images/ransomware.png")

It's clear that what needs to be done is to reverse the algorithm in the binary and decrypt the encrypted flag to solve the challenge. Let us drop the ransomware binary in IDA to see how exactly it is encrypting the files.

The starting point of our analysis on IDA obviously should be the `start` function as that is the entrypoint of the application. As shown below the `start` function does nothing but calls a function `sub_401000` with two arguments **(both zeroes)** pushed on the stack.

![alt text]({{ site.baseurl }}/images/ransomware1/start.png "{{ site.baseurl }}/images/start.png")

Entering the `sub_401000` function, we see some code of interest:

![alt text]({{ site.baseurl }}/images/ransomware1/start_initial_part.png "{{ site.baseurl }}/images/startinitial.png")

I have renamed the variables for easier readability of the codeflow. First on line 401022 there's a call to `snprintf` with the arguments `snprintf(&s, 0x104, "%s_encrypted", FileName)`. If we check the stack variable/arguments list right above where the code of `sub_401000` starts, we see `FileName` is the first argument that was passed to `sub_401000`. `snprintf` simply is a generalised version of printf where it outputs a string to a Buffer pointed to by the first argument passed to it, in our case the argument is `&s`, which is a 0x108 bytes long string on the stack (shown again in the stack variables list above). So this call will take whatever string `FileName` points to, append the string _encrypted_ to it, and place the string on the stack pointed to by `&s`.

Then there are two calls to the WINAPI `CreateFileA`. From MSDN, the prototype of `CreateFileA` is:
`HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);`

The two subsequents calls with their proper arguments are: 
1. `CreateFileA(FileName, 0x80000000, 0, 0, 3, 0x80, 0)` 
2. `CreateFileA(&s, 0x40000000, 0, 0, 2, 0x80, 0)`




