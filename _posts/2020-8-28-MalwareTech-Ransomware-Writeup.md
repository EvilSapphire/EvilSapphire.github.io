---
layout: post
title: MalwareTech Ransomware Writeup
---
## MalwareTech Ransomware1 Reversing challenge:

I was looking into the RE challenges posted by MalwareTech on his website found [here](https://www.malwaretech.com/beginner-malware-reversing-challenges). They deal with finding a flag in the Binaries in the form of **FLAG{}**. I solved all of them but the last [one](https://www.malwaretech.com/ransomware1), it dealt with a simple Ransomware sample that Encrypts some files with its custom algorithm. With the zip file came a __flag.txt_encrypted__, and a **Sample Picture** folder with encrypted pictures by the same ransomware :

![alt text]({{ site.baseurl }}/images/flag_encrypted.png "{{ site.baseurl }}/images/flag_encrypted.png")

![alt text]({{ site.baseurl }}/images/pictures_encrypted.png "{{ site.baseurl }}/images/pictures_encrypted.png")

![alt text]({{ site.baseurl }}/images/ransomware.png "{{ site.baseurl }}/images/ransomware.png")

It's clear that what needs to be done is to reverse the algorithm in the binary and decrypt the encrypted flag to solve the challenge. Let us drop the ransomware binary in IDA to see how exactly it is encrypting the files.

The starting point of our analysis on IDA obviously should be the `start` function as that is the entrypoint of the application. As shown below the `start` function does nothing but call a function `sub_401000` with two arguments **(both zeroes)** pushed on the stack.

![alt text]({{ site.baseurl }}/images/ransomware1/start.png "{{ site.baseurl }}/images/start.png")

Entering the `sub_401000` function, we see some code of interest:

![alt text]({{ site.baseurl }}/images/ransomware1/start_initial_part.png "{{ site.baseurl }}/images/startinitial.png")

I have renamed the variables for easier readability of the codeflow. First on line 401022 there's a call to `snprintf` with the arguments `snprintf(&s, 0x104, "%s_encrypted", FileName)`. If we check the stack variable/arguments list right above where the code of `sub_401000` starts, we see `FileName` is the first argument that was passed to `sub_401000`. `snprintf` simply is a generalised version of printf where it outputs a string to a Buffer pointed to by the first argument passed to it, in our case the argument is `&s`, which is a 0x108 bytes long string on the stack (shown again in the stack variables list above). So this call will take whatever string `FileName` points to, append the string _encrypted_ to it, and place the string on the stack pointed to by `&s`.

Then there are two calls to the WINAPI `CreateFileA`. From MSDN, the prototype of `CreateFileA` is:

```
HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);
```

The two subsequents calls with their proper arguments are: 
1. `CreateFileA(FileName, 0x80000000, 0, 0, 3, 0x80, 0)` 
2. `CreateFileA(&s, 0x40000000, 0, 0, 2, 0x80, 0)`

The difference between the two is that the first `CreateFileA` is being called on the string pointed to by `FileName` with `dwCreationDisposition` set to `OPEN_EXISTING`, and the second one is being called on the string pointed to by `&s` with `dwCreationDisposition` set to `CREATE_ALWAYS`. Therefore the first `CreateFileA` opens an existing file with the name pointed to by `FileName` and the second `CreateFileA` creates a file pointed to by `&s` which was a string with _encrypted_ appended to it after the `FileName` string. So basically the Malware opens a plaintext file pointed to by `FileName` and possibly encrypts it's content, create a file called <filename>_encrypted and write the encrypted content there.
  
After the `CreateFileA` called there is a big loop as shown below:

![alt text]({{ site.baseurl }}/images/ransomware1/dowhilefirst.png "{{ site.baseurl }}/images/ransomware1/dowhilefirst.png")
![alt text]({{ site.baseurl }}/images/ransomware1/dowhilesecond.png "{{ site.baseurl }}/images/ransomware1/dowhilesecond.png")

From the assembly structure it is clear it is a `do while` loop where the `ReadFile` WINAPI is called on the handle returned by the `CreateFileA` call to `FileName`. From MSDN the `ReadFile` prototype is:

`BOOL ReadFile(
  HANDLE       hFile,
  LPVOID       lpBuffer,
  DWORD        nNumberOfBytesToRead,
  LPDWORD      lpNumberOfBytesRead,
  LPOVERLAPPED lpOverlapped
);`

Therefore according to the prototype 0x1000 bytes is read from the file with `FileName` as its name, and the buffer is placed onto the string `PlainFileBuffer`. Also the actual number of bytes read from the file is stored in the 4th argument `PlainNumberOfBytesRead`. This same variable is passed to a `WriteFile` call down the line that writes some content to the file pointed to by the `&s` (FileName_encrypted) variable. The check for the do while loop is done against `PlainNumberOfBytesRead`, and in case it is less than 0x1000 bytes, the loop terminates. Therefore the do while loops over reading 0x1000 bytes from a file pointed to by `FileName`, processing that content in some way, and then writing that content to the file pointed to by `&s` until the number of bytes read/written is less than 0x1000.

The content read from the file is encrypted using a `for` loop inside this do while loop. A variable labelled `cnt` is initialised to zero and it is checked against `PlainNumberOfBytesRead`. In case `cnt < PlainNumberOfBytesRead` the loop iterates over each of the character of `PlainFileBuffer` (where content from the plaintext file was stored), and xors them over the character of a `Key`(which was passed as the second argument to `sub_401000`) variable with the key index divided by 0x20 and taking the remainder (which basically means the `key` is a 0x20 bytes long string) and stores back the character to `PlainTextBuffer`. This `PlainTextBuffer` is written into Filename_encrypted file down the line. So this is the meat of the encryption algorithm. Decompiling the algorithm by hand would look something like:

```
  do
  {
    if ( ReadFile(hPlainFile, PlainFileBuffer, 0x1000, &PlainNumberOfBytesRead, 0) != 1 )
      break;
    for ( cnt = 0; cnt < PlainNumberOfBytesRead; ++cnt )
      PlainFileBuffer[cnt] ^= Key[cnt % 0x20];
    WriteFile(hEncryptedFile, PlainFileBuffer, PlainNumberOfBytesRead, &PlainNumberOfBytesRead, 0);
  }
  while ( PlainNumberOfBytesRead == 0x1000 );
```
We have identified the encryption algorithm. However, the string labelled `Key` the characters of which are used to encrypt the file content was actually the second argument to `sub_401000`, and we have seen both the arguments passed to this function are zero. From MalwareTech's description of the challenge:
> One of our malware analysts was able to recover the encryption function from memory but doesnâ€™t know much about cryptography. Can you find a way to decrypt flag.txt?

Therefore the challenge is designed in such a way that we have to figure out the key using some other method than just looking at the encryption algorithm. This is how real life ransomwares work too as after the encryption is done the key will be sent in some way over the network to the attacker's C2C as if you leave the trace of the key in the binary sample the encryption algorithm can be reverse engineered and the encrypted content can easily be decrypted with the key now in the posession of the reverse engineer. So how do we go about figuring out the key?
From the "Sample Pictures" Folder in the "EncryptedFiles", we have a list of encrypted pictures named 'Chrysanthemum.jpg_encrypted', 'Hydrangeas.jpg_encrypted' etc (screenshot above). We know the content was encrypted using the XOR algorithm above. One interesting thing about XOR is that it is its own reverse operation. Which is to say:
If `result= (variable1) ^ (variable2)`, then `variable2= (result) ^ (variable1)`. Therefore, if we knew the PlainText of these encrypted files in any way, we could retrieve the key by XORing 0x20 bytes of PlainText with the corresponding 0x20 bytes of EncryptedText (since the Key is 0x20 bytes long). Now, before encryption the files must have been named 'Chrysanthemum.jpg', 'Hydrangeas.jpg' etc (which we figured out from the binary), which were JPG files. JPG/JPEG (Joint Photographic Experts Group) is actually an umbrella term for two different File formats: JPG/EXIF and JPG/JFIF. JPG/JFIF is more common in World Wide Web and Windows OS, which like all file formats has some fixed file headers that are in the first few bytes of any JPG/JFIF file. Viewing one of the random JPG files stored in my Windows 10 PC in a Hexdump tool (I'm using HxD) gives me the first 0x20 bytes of the file:

![alt text]({{ site.baseurl }}/images/ransomware1/InternetFreedomFoundation.JPG "{{ site.baseurl }}/images/ransomware1/InternetFreedomFoundation.jpg")

Unfortunately I think the JFIF header is less than 0x20 bytes long as it doesn't seem something like a 'Photoshop' string would be placed in a general JFIF header. However, we can still take this as a starting point and read 0x20 bytes from my sample plaintext file, XOR it with 0x20 bytes of a encrypted jpg file, which would be the best guess for our key, and XOR the key cyclically (since from the below screenshot the encrypted key is bytes long) with the contents of the flag.txt_encrypted file and see how many of the characters of the flag we are able to retrieve. 

![alt text]({{ site.baseurl }}/images/flag_encrypted.JPG "{{ site.baseurl }}/images/flag_encrypted.jpg")

The Python script below is written to perform exactly the decryption as explained above:
```
fenc= open('Hydrangeas.jpg_encrypted','rb')
fplain= open('InternetFreedomFoundation.jpg', 'rb')

flagenc= open('flag.txt_encrypted','rb').read(0x3b)
flagdecrypt= open('decryptedflag.bin','a')

flagplain= []
encr= fenc.read(0x20)
plain= fplain.read(0x20)
key= [0]*0x20


for i in range(0,0x1F):
 key[i]= plain[i]^encr[i]


flagplainstr= ""
keystr= ""

for i in range(0,0x3b):
     flagplain.append(flagenc[i]^key[i%0x20]                 
    
for byte in flagplain:
    flagplainstr+=chr(byte)
    flagdecrypt.write(chr(byte))
   
print(flagplainstr)  

```
Running the script gives the following output on console:

![alt text]({{ site.baseurl }}/images/ransomware1/decryptedflag_console.JPG "{{ site.baseurl }}/images/ransomware1/decryptedflag_console.JPG")

Viewing the decryptedflag.bin file in HxD gives us a better idea of the decrypted flag content and the offsets (also because the Key is incomplete, some bytes may have been decrypted wrongly which doesn't have a valid Unicode encoding which is what Python 3 uses, and therefore will not be printed out to the console):

![alt text]({{ site.baseurl }}/images/decryptedflagbin_1.JPG "{{ site.baseurl }}/images/decryptedflagbin_1.JPG")

Obviously the entire flag has not been decrypted correctly. However, given the format of the flag **FLAG{}** we can infer the ending byte must be '}' or 0x7D. Also it seems the english word starting at 0xF offset in the decrypted flag is 'KNOWN'. We can use this information to calculate the corresponding bytes in the Key. For example, if the character at 0xF offset is 'K' or 0x4B, therefore the Key byte at 0xF offset must be `0x4b ^ 0xB`, since 0xB is the corresponding byte in the encrypted flag (refer to the encrypted flag screenshot above). This works out to be 0x40. Setting this byte in the Key also will properly decrypt the byte at 0x1F offset since the key is 0x20 bytes long and it cycles over once we reach the 0x20th byte in the encrypted flag and starts over from the 1st byte of the key. Similarly the other 2 bytes in the key can be manually set in the python script with:

`
key[0xf]= 0x40
key[0x11]= 0xf5
key[0x1A]= 0x8d

`

Updating the key and running the script again gives the following decrypted key:

![alt text]({{ site.baseurl }}/images/ransomeware1/decryptedflagbin_2.JPG "{{ site.baseurl }}/images/ransomeware1/decryptedflagbin_2.JPG")

