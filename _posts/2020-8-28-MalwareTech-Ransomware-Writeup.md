---
layout: post
title: MalwareTech Ransomware Writeup
---
## MalwareTech Ransomware1 Reversing challenge:

I was looking into the RE challenges posted by MalwareTech on his website found [here](https://www.malwaretech.com/beginner-malware-reversing-challenges). They deal with finding a flag in the Binaries in the form of **FLAG{}**. I solved all of them but the last [one](https://www.malwaretech.com/ransomware1), it dealt with a simple Ransomware sample that Encrypts some files with it's custom algorithm. With the zip file came a __flag.txt_encrypted__, and a **Sample Picture** folder with encrypted pictures by the same ransomware :

![alt text]({{ site.baseurl }}/images/flag_encrypted.png "{{ site.baseurl }}/images/flag_encrypted.png")

![alt text]({{ site.baseurl }}/images/pictures_encrypted.png "{{ site.baseurl }}/images/pictures_encrypted.png")

![alt text]({{ site.baseurl }}/images/ransomware.png "{{ site.baseurl }}/images/ransomware.png")

It's clear that what needs to be done is to reverse the algorithm in the binary and decrypt the encrypted flag to solve the challenge. Let us drop the ransomware binary in IDA to see how exactly it is encrypting the files.

The starting point of our analysis on IDA obviously should be the `start` function as that is the entrypoint of the application. As shown below the `start` function does nothing but calls a function `sub_401000` with two arguments **(both zeroes)** pushed on the stack.

![alt text]({{ site.baseurl }}/images/ransomware1/start.png "{{ site.baseurl }}/images/start.png")

Entering the `sub_401000` function, we see some code of interest:

![alt text]({{ site.baseurl }}/images/ransomware1/start_initial_part.png "{{ site.baseurl }}/images/startinitial.png")

I have renamed the variables for easier readability of the codeflow. First on line 401022 there's a call to `snprintf` with the arguments `snprintf(&s, 0x104, "%s_encrypted", FileName)`. If we check the stack variable/arguments list right above where the code of `sub_401000` starts, we see `FileName` is the first argument that was passed to `sub_401000`. `snprintf` simply is a generalised version of printf where it outputs a string to a Buffer pointed to by the first argument passed to it, in our case the argument is `&s`, which is a 0x108 bytes long string on the stack (shown again in the stack variables list above). So this call will take whatever string `FileName` points to, append the string _encrypted_ to it, and place the string on the stack pointed to by `&s`.

Then there are two calls to the WINAPI `CreateFileA`. From MSDN, the prototype of `CreateFileA` is:

`HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);`

The two subsequents calls with their proper arguments are: 
1. `CreateFileA(FileName, 0x80000000, 0, 0, 3, 0x80, 0)` 
2. `CreateFileA(&s, 0x40000000, 0, 0, 2, 0x80, 0)`

The difference between the two is that the first `CreateFileA` is being called on the string pointed to by `FileName` with `dwCreationDisposition` set to `OPEN_EXISTING`, and the second second one is being called on the string pointed to by `&s` with `dwCreationDisposition` set to `CREATE_ALWAYS`. Therefore the first `CreateFileA` opens an existing file with the name pointed to by `FileName` and the second `CreateFileA` creates a file pointed to by `&s` which was a string with _encrypted_ appended to it after the `FileName` string. So basically the Malware opens a plaintext file pointed to by `FileName` and possibly will encrypt it's content, create a file called <filename>_encrypted and write the encrypted content there.
  
After the `CreateFileA` called there is a big loop as shown below:

![alt text]({{ site.baseurl }}/images/ransomware1/dowhilefirst.png "{{ site.baseurl }}/images/ransomware1/dowhilefirst.png")
![alt text]({{ site.baseurl }}/images/ransomware1/dowhilesecond.png "{{ site.baseurl }}/images/ransomware1/dowhilesecond.png")

From the assembly structure it is clear it is a `do while` loop where the `ReadFile` WINAPI is called on the handle returned by the `CreateFileA` call to `FileName`. From MSDN the `ReadFile` prototype is:

`BOOL ReadFile(
  HANDLE       hFile,
  LPVOID       lpBuffer,
  DWORD        nNumberOfBytesToRead,
  LPDWORD      lpNumberOfBytesRead,
  LPOVERLAPPED lpOverlapped
);`

Therefore according to the prototype 0x1000 bytes is read from the file with `FileName` as its name, and the buffer is placed onto the string `PlainFileBuffer`. Also the actual number of bytes read from the file is stored in the 4th argument `PlainNumberOfBytesRead`. This same variable is passed to a `WriteFile` call down below that writes some content to the file pointed to by the `&s` (FileName_encrypted) variable. The check for the do while loop is done against `PlainNumberOfBytesRead`, and in case it is less than 0x1000 bytes, the loop terminates. Therefore the do while loops over reading 0x1000 bytes from a file pointed to by `FileName`, processing that content in some way, and then writing that content to the file pointed to by `&s` until the number of bytes read/written is less than 0x1000.

The content read from the file is encrypted using a `for` loop inside this do while loop. A variable labelled `cnt` is initialised to zero and it is checked against `PlainNumberOfBytesRead`. In case `cnt`<`PlainNumberOfBytesRead` the loop iterates over each of the character of `PlainFileBuffer` (where content from the plaintext file was stored), and xors them over the character of a `Key`(which was passed as the second argument to `sub_401000`) variable with the index divided by 0x20 and taking the remainder (which basically means the `key` is a 0x20 bytes long string) and stores back the character to `PlainTextBuffer`. This `PlainTextBuffer` is written into Filename_encrypted file down the line. So this is the meat of the encryption algorithm. Decompiling the algorithm by hand would look something like:

`do
  {
    if ( ReadFile(hPlainFile, PlainFileBuffer, 0x1000, &PlainNumberOfBytesRead, 0) != 1 )
      break;
    for ( cnt = 0; cnt < PlainNumberOfBytesRead; ++cnt )
      PlainFileBuffer[cnt] ^= Key[cnt % 0x20];
    WriteFile(hEncryptedFile, PlainFileBuffer, PlainNumberOfBytesRead, &PlainNumberOfBytesRead, 0);
  }
  while ( PlainNumberOfBytesRead == 0x1000 );
``

